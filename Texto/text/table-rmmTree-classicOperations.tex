\begin{table}[h!]
	\centering
	\caption[Operações sobre a RMM-tree clássica]{Operações suportadas pela rmM-tree bináriaW}
	\label{tbl:classicOperations-rmm-tree}
	\rowcolors{2}{lightgray!30}{white}
	\resizebox{\columnwidth}{!}{
	\begin{tabular}{ll}
	\toprule
	\textbf{Operação} & \textbf{Retorno} \\
	\toprule
    
	fwdSearch(i,d)  & Índice $j$, tal que $excess(j) = excess(i) + d$\\
	bwdSearch(i,d)  & Índice $j$, tal que $excess(j+1,i) = -d$\\
	minExcess(i,j) / maxExcess(i,j)  & Excesso mínimo/máximo em $i,j$\\
	minCount(i,j)  & Número de vezes que o excesso mínimo aparece em $i,j$\\
	minSelectExcess(i,j,t)  & Índice da $t-$ésima ocorrência do excesso mínimo em um intervalo\\
	enclose(i) & Posição do parênteses de abertura que envolve  $BV[i]$  \\
	rmq(i,j) / rMq(i,j) & $p>=i$ mais à esquerda de $i$, onde ocorre o excesso mínimo/máximo do intervalo dado \\
	rank$_1$(i) / rank$_0$(i) & Número de parênteses abrindo/fechando em $BV[0,i]$ \\
    select$_1$(i) / select$_0$(i) & Posição do i-ésimo parênteses de abertura/fechamento\\
    preRank(i)/postRank(i) & rank de $i$ calculado a partir de um percurso \textit{preorder \mbox{ ou } postorder} \\
    preSelect(i)/postSelect(i) & retorna o nó com \textit{preorder/postorder} $i$\\
    isLeaf(i) & Verifica se $BV[i]$ codifica uma folha \\
    isAncestor(i,j) & Verifica se o nó codificado em $i$ é ancestral de $j$ \\
    depth(i) & Profundidade do nó $i$ \\
    parent(i) & Obtém o pai do nó $i$ \\
    firstChild(i) / lastChild(i) & Retorna o primeiro/último filho do nó codficiado em $BV[i]$ \\
    child(i,t)&$t-$ésimo filho do nó codificado em $i$\\
    nextSibling(i) / prevSibling(i) & Primeiro irmão à direita/esquerda de $i$ \\
    subtreeSize(i) & Número de nós enraízados na subárvore de $i$ \\
    levelAncestor(i,d) & Ancestral $j$ de $i$ tal que $depth(j) = depth(i) - d$\\
    levelNext(i) / levelPrev(i) & Nó à direita/esquerda de $i$ com a mesma profundidade de $i$.\\
    levelLeftMost(d) / levelRightMost(d) &Nó mais à esquerda/direita, com profundidade d.\\
    lca(i,j)&Menor ancestral comum dos nós codificados em $i$ e $j$\\
    deepestNode(i)&Nó mais profundo de $i$ (mais à direita possível)\\
    degree(i)&Número de filhos do nó $i$ \\
    childRank(i)&Número de irmãos à esquerda do nó codificado em $i$\\
    leafRank(i)& Número de folhas à esquerda da folha codificada em $i$ \\
    leafSelect(i)& $i-$ésima folha em $BV[0,size-1]$ \\
    leftMostLeaf(i)& folha codificada em $j$, mais à direita de $i$, tal que $j<i$\\
    rightMostLeaf(i)& folha codificada em $j$, mais à direita possível, tal que $j \leq i$\\
	\bottomrule
	\end{tabular}
	}
\end{table}