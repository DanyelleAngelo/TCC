\chapter{Considerações Finais}\label{chp:conclusao}

Com o surgimento de novos dispositivos e o aumento na produção de dados, temos um grande desafio a superar frente ao gargalo de comunicação existente entre memória e processador. Soluções como hierarquia de memória objetivam diminuir esse gargalo, entretanto quando se trabalha com uma alta quantidade de dados, estes tendem a ficar distribuídos entre os diferentes níveis de memória. Com isso o processador frequentemente precisa realizar buscas em memórias  nos níveis mais inferiores da hierarquia, o que acarreta em um acréscimo de tempo considerável no tempo de resposta do sistema, devido a alta latência dessas memórias.

As estruturas de dados sucintas possibilitam a representação e operaração sobre os seus objetos, usando espaço e tempo reduzido. Assim um dos objetivos deste trabalho era compreender e enfatizar a importância do estudo dessas estruturas. Ao operar na memória principal, temos um novo gargalo de desempenho, dessa vez entre cache e memória principal, como mostram \citet{paper-making-btree-cache}, desse modo faz-se necessário buscarmos maneiras de melhor aproveitar a estrutura da memória cache. Uma das maneiras de fazer isso é tirando proveito da localidade espacial, maximizando o uso de uma linha de cache, que pode ser alcançada através da maximização do fator de ramificação destas estruturas. 

A rmM-tree é uma estrutura de dados sucinta que permite a navegação de forma eficiente em árvores, através de valores de excesso máximos e mínimos em intervalos, porém a mesma é construída no formato de árvore binária, uma estrutura que possuí baixo fator de ramificação, e portanto baixo aproveitamento da linha de cache, nosso objetivo neste trabalho portanto era aumentar o fator de ramificação dessa estrutura, visando  melhor proveito da cache, como visto em \citet{paper-making-btree-cache}, o que reduziria significativamente o tempo gasto para realizar operações diversas. 

Implementamos e analisamos, para tanto, uma versão da rmM-tree de \citet{book-compact-data-structures}, e 3 versões de uma rmM-tree k-kária, compreendendo uma rmM-tree 4-ária, 8-ária, e uma rmM-tree 16-ária. De modo geral, os resultados obtidos a partir destas implementações não foram satisfatórios. Comparando a rmM-tree binária, frente às diferentes versões da rmM-tree k-ária, a primeira teve melhor desempenho em todas as operações. Em relação à rmM-tree k-ária, não foi possível detectar um padrão de comportamento para os diferentes conjuntos de dados usados nos testes. 

Para trabalhos futuros temos como objetivo reduzir o tempo das operações, através da otimização da implementação da rmM-tree k-ária. É necessário também melhorar o escopo dos nossos testes afim de monitorar de  modo mais claro e eficaz o uso da cache, o que envolve ampliar o escopo das ferramentas usadas. Sugere-se também investigar o impacto dessa proposta em diferentes ambientes, visando entender o efeito dessa estrutura diante de diferentes configurações de hardware. Por último temos como objetivo a implementação das demais operações de percurso em árvores suportadas pela range min-max tree clássica e que ainda não foram implementadas em sua versão k-ária. 
